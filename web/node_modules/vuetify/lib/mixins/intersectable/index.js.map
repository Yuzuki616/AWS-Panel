{"version":3,"sources":["../../../src/mixins/intersectable/index.ts"],"names":[],"mappings":"AAAA;AACA,OAAO,SAAP,MAAsB,4BAAtB,C,CAEA;;AACA,SAAS,WAAT,QAA4B,oBAA5B,C,CAEA;;AACA,OAAO,GAAP,MAAgB,KAAhB;AAEA,eAAc,SAAU,aAAV,CAAyB,OAAzB,EAAyD;AACrE,SAAO,GAAG,CAAC,MAAJ,CAAW;AAChB,IAAA,IAAI,EAAE,eADU;AAGhB,IAAA,IAAI,EAAE,OAAO;AACX,MAAA,cAAc,EAAE;AADL,KAAP,CAHU;;AAOhB,IAAA,OAAO,GAAA;AACL,MAAA,SAAS,CAAC,QAAV,CAAmB,KAAK,GAAxB,EAA4C;AAC1C,QAAA,IAAI,EAAE,WADoC;AAE1C,QAAA,KAAK,EAAE,KAAK;AAF8B,OAA5C,EAGG,KAAK,MAHR;AAID,KAZe;;AAchB,IAAA,SAAS,GAAA;AACP,MAAA,SAAS,CAAC,MAAV,CAAiB,KAAK,GAAtB,EAA0C;AACxC,QAAA,IAAI,EAAE,WADkC;AAExC,QAAA,KAAK,EAAE,KAAK;AAF4B,OAA1C,EAGG,KAAK,MAHR;AAID,KAnBe;;AAqBhB,IAAA,OAAO,EAAE;AACP,MAAA,SAAS,CAAE,OAAF,EAAwC,QAAxC,EAAwE,cAAxE,EAA+F;AACtG,aAAK,cAAL,GAAsB,cAAtB;AAEA,YAAI,CAAC,cAAL,EAAqB;;AAErB,aAAK,IAAI,CAAC,GAAG,CAAR,EAAW,MAAM,GAAG,OAAO,CAAC,SAAR,CAAkB,MAA3C,EAAmD,CAAC,GAAG,MAAvD,EAA+D,CAAC,EAAhE,EAAoE;AAClE,gBAAM,QAAQ,GAAI,KAAa,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAAb,CAAlB;;AAEA,cAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,YAAA,QAAQ;AACR;AACD;;AAED,UAAA,WAAW,CAAC,OAAO,CAAC,SAAR,CAAkB,CAAlB,IAAuB,wFAAxB,CAAX;AACD;AACF;;AAhBM;AArBO,GAAX,CAAP;AAwCD","sourcesContent":["// Directives\nimport Intersect from '../../directives/intersect'\n\n// Utilities\nimport { consoleWarn } from '../../util/console'\n\n// Types\nimport Vue from 'vue'\n\nexport default function intersectable (options: { onVisible: string[] }) {\n  return Vue.extend({\n    name: 'intersectable',\n\n    data: () => ({\n      isIntersecting: false,\n    }),\n\n    mounted () {\n      Intersect.inserted(this.$el as HTMLElement, {\n        name: 'intersect',\n        value: this.onObserve,\n      }, this.$vnode)\n    },\n\n    destroyed () {\n      Intersect.unbind(this.$el as HTMLElement, {\n        name: 'intersect',\n        value: this.onObserve,\n      }, this.$vnode)\n    },\n\n    methods: {\n      onObserve (entries: IntersectionObserverEntry[], observer: IntersectionObserver, isIntersecting: boolean) {\n        this.isIntersecting = isIntersecting\n\n        if (!isIntersecting) return\n\n        for (let i = 0, length = options.onVisible.length; i < length; i++) {\n          const callback = (this as any)[options.onVisible[i]]\n\n          if (typeof callback === 'function') {\n            callback()\n            continue\n          }\n\n          consoleWarn(options.onVisible[i] + ' method is not available on the instance but referenced in intersectable mixin options')\n        }\n      },\n    },\n  })\n}\n"],"sourceRoot":"","file":"index.js"}
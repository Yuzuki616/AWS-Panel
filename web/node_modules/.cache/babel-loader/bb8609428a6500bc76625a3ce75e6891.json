{"remainingRequest":"/home/chengege/AWS-Panel-master/web/node_modules/thread-loader/dist/cjs.js!/home/chengege/AWS-Panel-master/web/node_modules/babel-loader/lib/index.js!/home/chengege/AWS-Panel-master/web/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/home/chengege/AWS-Panel-master/web/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/home/chengege/AWS-Panel-master/web/babel.config.js","mtime":1652337639000},{"path":"/home/chengege/AWS-Panel-master/web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/chengege/AWS-Panel-master/web/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/chengege/AWS-Panel-master/web/node_modules/babel-loader/lib/index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL2hvbWUvY2hlbmdlZ2UvQVdTLVBhbmVsLW1hc3Rlci93ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanMiOwppbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAiL2hvbWUvY2hlbmdlZ2UvQVdTLVBhbmVsLW1hc3Rlci93ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiL2hvbWUvY2hlbmdlZ2UvQVdTLVBhbmVsLW1hc3Rlci93ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOwppbXBvcnQgeyBjYW1lbGl6ZSwgd3JhcEluQXJyYXkgfSBmcm9tICcuL2hlbHBlcnMnOwp2YXIgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICB2YXIgc3R5bGVNYXAgPSB7fTsKCiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0eWxlLnNwbGl0KHBhdHRlcm4uc3R5bGVMaXN0KSksCiAgICAgIF9zdGVwOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIHMgPSBfc3RlcC52YWx1ZTsKCiAgICAgIHZhciBfcyRzcGxpdCA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApLAogICAgICAgICAgX3Mkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Mkc3BsaXQsIDIpLAogICAgICAgICAga2V5ID0gX3Mkc3BsaXQyWzBdLAogICAgICAgICAgdmFsID0gX3Mkc3BsaXQyWzFdOwoKICAgICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICAgIGlmICgha2V5KSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgICAgICB2YWwgPSB2YWwudHJpbSgpOwogICAgICB9CgogICAgICBzdHlsZU1hcFtjYW1lbGl6ZShrZXkpXSA9IHZhbDsKICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvci5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvci5mKCk7CiAgfQoKICByZXR1cm4gc3R5bGVNYXA7Cn0KCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlRGF0YSgpIHsKICB2YXIgbWVyZ2VUYXJnZXQgPSB7fTsKICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIHByb3A7IC8vIEFsbG93IGZvciB2YXJpYWRpYyBhcmd1bWVudCBsZW5ndGguCgogIHdoaWxlIChpLS0pIHsKICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgZGF0YSBwcm9wZXJ0aWVzIGFuZCBleGVjdXRlIG1lcmdlIHN0cmF0ZWdpZXMKICAgIC8vIE9iamVjdC5rZXlzIGVsaW1pbmF0ZXMgbmVlZCBmb3IgaGFzT3duUHJvcGVydHkgY2FsbAogICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhhcmd1bWVudHNbaV0pOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHsKICAgICAgcHJvcCA9IF9PYmplY3Qka2V5c1tfaV07CgogICAgICBzd2l0Y2ggKHByb3ApIHsKICAgICAgICAvLyBBcnJheSBtZXJnZSBzdHJhdGVneSAoYXJyYXkgY29uY2F0ZW5hdGlvbikKICAgICAgICBjYXNlICdjbGFzcyc6CiAgICAgICAgY2FzZSAnZGlyZWN0aXZlcyc6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VDbGFzc2VzKG1lcmdlVGFyZ2V0W3Byb3BdLCBhcmd1bWVudHNbaV1bcHJvcF0pOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdzdHlsZSc6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VTdHlsZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gU3BhY2UgZGVsaW1pdGVkIHN0cmluZyBjb25jYXRlbmF0aW9uIHN0cmF0ZWd5CgogICAgICAgIGNhc2UgJ3N0YXRpY0NsYXNzJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChtZXJnZVRhcmdldFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gJyc7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIC8vIE5vdCBhbiBlbXB0eSBzdHJpbmcsIHNvIGNvbmNhdGVuYXRlCiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9ICcgJzsKICAgICAgICAgIH0KCiAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSArPSBhcmd1bWVudHNbaV1bcHJvcF0udHJpbSgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gT2JqZWN0LCB0aGUgcHJvcGVydGllcyBvZiB3aGljaCB0byBtZXJnZSB2aWEgYXJyYXkgbWVyZ2Ugc3RyYXRlZ3kgKGFycmF5IGNvbmNhdGVuYXRpb24pLgogICAgICAgIC8vIENhbGxiYWNrIG1lcmdlIHN0cmF0ZWd5IG1lcmdlcyBjYWxsYmFja3MgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXksCiAgICAgICAgLy8gc28gdGhhdCB0aGUgbGFzdCBkZWZpbmVkIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBmaXJzdC4KICAgICAgICAvLyBUaGlzIGlzIGRvbmUgc2luY2UgdG8gbWltaWMgaG93IE9iamVjdC5hc3NpZ24gbWVyZ2luZwogICAgICAgIC8vIHVzZXMgdGhlIGxhc3QgZ2l2ZW4gdmFsdWUgdG8gYXNzaWduLgoKICAgICAgICBjYXNlICdvbic6CiAgICAgICAgY2FzZSAnbmF0aXZlT24nOgogICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IG1lcmdlTGlzdGVuZXJzKG1lcmdlVGFyZ2V0W3Byb3BdLCBhcmd1bWVudHNbaV1bcHJvcF0pOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCBtZXJnZSBzdHJhdGVneQoKICAgICAgICBjYXNlICdhdHRycyc6CiAgICAgICAgY2FzZSAncHJvcHMnOgogICAgICAgIGNhc2UgJ2RvbVByb3BzJzoKICAgICAgICBjYXNlICdzY29wZWRTbG90cyc6CiAgICAgICAgY2FzZSAnc3RhdGljU3R5bGUnOgogICAgICAgIGNhc2UgJ2hvb2snOgogICAgICAgIGNhc2UgJ3RyYW5zaXRpb24nOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IHt9OwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhcmd1bWVudHNbaV1bcHJvcF0pLCBtZXJnZVRhcmdldFtwcm9wXSk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBSZWFzc2lnbm1lbnQgc3RyYXRlZ3kgKG5vIG1lcmdlKQoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgLy8gc2xvdCwga2V5LCByZWYsIHRhZywgc2hvdywga2VlcEFsaXZlCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdOwogICAgICAgICAgfQoKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1lcmdlVGFyZ2V0Owp9CmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN0eWxlcyh0YXJnZXQsIHNvdXJjZSkgewogIGlmICghdGFyZ2V0KSByZXR1cm4gc291cmNlOwogIGlmICghc291cmNlKSByZXR1cm4gdGFyZ2V0OwogIHRhcmdldCA9IHdyYXBJbkFycmF5KHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gcGFyc2VTdHlsZSh0YXJnZXQpIDogdGFyZ2V0KTsKICByZXR1cm4gdGFyZ2V0LmNvbmNhdCh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHBhcnNlU3R5bGUoc291cmNlKSA6IHNvdXJjZSk7Cn0KZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ2xhc3Nlcyh0YXJnZXQsIHNvdXJjZSkgewogIGlmICghc291cmNlKSByZXR1cm4gdGFyZ2V0OwogIGlmICghdGFyZ2V0KSByZXR1cm4gc291cmNlOwogIHJldHVybiB0YXJnZXQgPyB3cmFwSW5BcnJheSh0YXJnZXQpLmNvbmNhdChzb3VyY2UpIDogc291cmNlOwp9CmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxpc3RlbmVycygpIHsKICBpZiAoIShhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdOwogIGlmICghKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07CiAgdmFyIGRlc3QgPSB7fTsKCiAgZm9yICh2YXIgaSA9IDI7IGktLTspIHsKICAgIHZhciBhcmcgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07CgogICAgZm9yICh2YXIgZXZlbnQgaW4gYXJnKSB7CiAgICAgIGlmICghYXJnW2V2ZW50XSkgY29udGludWU7CgogICAgICBpZiAoZGVzdFtldmVudF0pIHsKICAgICAgICAvLyBNZXJnZSBjdXJyZW50IGxpc3RlbmVycyBiZWZvcmUgKGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBiYWNrd2FyZHMpLgogICAgICAgIC8vIE5vdGUgdGhhdCBuZWl0aGVyICJ0YXJnZXQiIG9yICJzb3VyY2UiIG11c3QgYmUgYWx0ZXJlZC4KICAgICAgICBkZXN0W2V2ZW50XSA9IFtdLmNvbmNhdChhcmdbZXZlbnRdLCBkZXN0W2V2ZW50XSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gU3RyYWlnaHQgYXNzaWduLgogICAgICAgIGRlc3RbZXZlbnRdID0gYXJnW2V2ZW50XTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGRlc3Q7Cn0="},{"version":3,"mappings":"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","names":["camelize","wrapInArray","pattern","styleList","styleProp","parseStyle","style","styleMap","split","s","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","dest","arg","event"],"sourceRoot":"","sources":["../../src/util/mergeData.ts"],"sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"]}]}